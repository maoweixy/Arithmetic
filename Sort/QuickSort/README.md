1.算法思想
	运用了分治法：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。
         设当前待排序的无序区为R[low..high]，利用分治法可将快速排序的基本思想描述为：
①分解： 
    　在R[low..high]中任选一个记录作为基准(Pivot)，以此基准将当前无序区划分为左、右两个较小的子区间R[low..pivotpos-1)和R[pivotpos+1..high]，并使左边子区间中所有记录的关键字均小于等于基准记录(不妨记为pivot)的关键字pivot.key，右边的子区间中所有记录的关键字均大于等于pivot.key，而基准记录pivot则位于正确的位置(pivotpos)上，它无须参加后续的排序。

2.代码讲解
     
#include<iostream>
using namespace std;

int par(double r[], int i, int j)
{
	double v = r[i];       把数组第一个值赋给基值
	while(i < j)
	{
		while(i < j && v <= r[j])          从最右边开始，依次把值与基值比较，直到碰见比机基值小的值（r[j]），然后把r[j]的值赋给r[i]
		{                                                    刚开始的r[i]就是基值
			j--;
		}
		if(i < j)
		{
			r[i] = r[j];
			i++;
		}
		while(i < j && v >= r[i])        从最左边开始，依次把值与基值比较，直到碰见比基值大的值（r[i]），然后把r[i]的值赋给r[j]
		{
			i++;
		}
		if(i < j)
		{
			r[j] = r[i];
			j--;
		}
	}
	r[i] = v;
	return i;
}

void Sort(double r[],int i, int j)
{
	int p;
	if(i < j)
	{
		p = par(r, i, j);
		Sort(r, i, p - 1);
		Sort(r, p + 1, j);
	}
}

int main()
{
	double r[5] = {23, 11, 65, 56, 72};
	Sort(r, 0, 4);
	for(int i = 0; i < 5; i++)
	{
		cout << r[i] << " ";
	}
	return 0;
}
（1）最坏时间复杂度
    　最坏情况是每次划分选取的基准都是当前无序区中关键字最小(或最大)的记录，划分的结果是基准左边的子区间为空(或右边的子区间为空)，而划分所得的另一个非空的子区间中记录数目，仅仅比划分前的无序区中记录个数减少一个。
    　因此，快速排序必须做n-1次划分，第i次划分开始时区间长度为n-i+1，所需的比较次数为n-i(1≤i≤n-1)，故总的比较次数达到最大值：
               Cmax = n(n-1)/2=O(n2)
    　如果按上面给出的划分算法，每次取当前无序区的第1个记录为基准，那么当文件的记录已按递增序(或递减序)排列时，每次划分所取的基准就是当前无序区中关键字最小(或最大)的记录，则快速排序所需的比较次数反而最多。

（2）	最好时间复杂度
    　在最好情况下，每次划分所取的基准都是当前无序区的"中值"记录，划分的结果是基准的左、右两个无序子区间的长度大致相等。总的关键字比较次数：
        0(nlgn)
3.算法分析
