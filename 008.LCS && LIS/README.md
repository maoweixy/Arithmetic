## LCS 最长公共子序列&&最长公共子串 &&LIS 最长递增子序列 ##


----------
本次将由浅入深的讲解如何解决上面三个问题
##求最长公共子序列个数（Main）
此题可用动态规划求解，首先找到</br>
1.**状态**（用来描述该问题的子问题的解）
求最长公共子串，如果将字符串剪短，还是求最长公共子串，并且剪短的字符串的最长公共子串一定是原来字符串最长公共子串的一部分，所以问题具有最优子结构特征</br>
2.**状态转移方程式**</br>
![此处输入图片的描述][1]


  [1]: http://hi.csdn.net/attachment/201108/17/0_1313577392SuoV.gif
我采用了从上往下，本可以加上备忘录，减少递归次数，这点我会在下面方法上加上。
##打印出最长公共子序列（Main1）
仅用动态规划是不够，因为需要打印出来，所以需要回溯。使用简单的回溯只能打印出一个最优解（与背包问题和倒酒问题类似），Main2.java使用的回溯方法和背包、倒酒一样只能解出一个最优解，但是写法简单一些，可以学习学习。Main3.java在回溯中加入递归，可以求出所有最优解。
这是与一个最优解不同的精华：

    if (X.charAt(i - 1) == Y.charAt(j - 1)) {
				Lcs += X.charAt(i - 1);
				i--;
				j--;
			}else {
				if (table[i - 1][j] > table[i][j - 1]) {
					i--;
				}
				else if (table[i - 1][j] < table[i][j - 1]) {
					j--;
				}else {
					TraceBack(i - 1, j, Lcs);
					TraceBack(i, j - 1, Lcs);
					return;
				}
			}
当table[i - 1][j] == table[i][j - 1]时递归（因为有多个最优解才会相等），正是如此才能求出多个最优解。
